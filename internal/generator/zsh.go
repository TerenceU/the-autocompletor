package generator

import (
	"fmt"
	"strings"

	"github.com/TerenceU/the-autocompletor/internal/model"
)

// Zsh generates a zsh completion script for the given command tree.
func Zsh(cmd *model.Command) string {
	var b strings.Builder
	name := cmd.Name

	fmt.Fprintf(&b, "#compdef %s\n", name)
	fmt.Fprintf(&b, "# Zsh completions for %s (generated by theautocompletor)\n\n", name)
	fmt.Fprintf(&b, "_%s() {\n", name)
	b.WriteString("    local state\n\n")

	if len(cmd.Subcommands) > 0 {
		b.WriteString("    _arguments \\\n")
		// Root flags
		for _, f := range cmd.Flags {
			b.WriteString(zshArg(f))
		}
		b.WriteString("        '1:command:->command' \\\n")
		b.WriteString("        '*::args:->args'\n\n")

		b.WriteString("    case $state in\n")
		b.WriteString("        command)\n")
		b.WriteString("            local -a subcommands\n")
		b.WriteString("            subcommands=(\n")
		for _, sub := range cmd.Subcommands {
			fmt.Fprintf(&b, "                '%s:%s'\n", sub.Name, escapeSingleQuote(sub.Description))
		}
		b.WriteString("            )\n")
		b.WriteString("            _describe 'subcommand' subcommands\n")
		b.WriteString("            ;;\n")

		b.WriteString("        args)\n")
		b.WriteString("            case $words[1] in\n")
		for _, sub := range cmd.Subcommands {
			if len(sub.Flags) == 0 {
				continue
			}
			fmt.Fprintf(&b, "                %s)\n", sub.Name)
			b.WriteString("                    _arguments \\\n")
			for _, f := range sub.Flags {
				b.WriteString(zshArg(f))
			}
			b.WriteString("                    ;;\n")
		}
		b.WriteString("            esac\n")
		b.WriteString("            ;;\n")
		b.WriteString("    esac\n")
	} else {
		b.WriteString("    _arguments \\\n")
		for _, f := range cmd.Flags {
			b.WriteString(zshArg(f))
		}
		b.WriteString("        && return 0\n")
	}

	fmt.Fprintf(&b, "}\n\n_%s \"$@\"\n", name)
	return b.String()
}

func zshArg(f model.Flag) string {
	var spec string
	if f.Short != "" && f.Long != "" {
		spec = fmt.Sprintf("'(%s %s)'", f.Short, f.Long)
		if f.TakesArg {
			spec += fmt.Sprintf("{%s,%s}[%s]:value:_files", f.Short, f.Long, escapeSingleQuote(f.Description))
		} else {
			spec += fmt.Sprintf("{%s,%s}[%s]", f.Short, f.Long, escapeSingleQuote(f.Description))
		}
	} else {
		flag := f.Long
		if flag == "" {
			flag = f.Short
		}
		if f.TakesArg {
			spec = fmt.Sprintf("'%s[%s]:value:_files'", flag, escapeSingleQuote(f.Description))
		} else {
			spec = fmt.Sprintf("'%s[%s]'", flag, escapeSingleQuote(f.Description))
		}
	}
	return fmt.Sprintf("        %s \\\n", spec)
}

func escapeSingleQuote(s string) string {
	return strings.ReplaceAll(s, "'", `'\''`)
}
