package generator

import (
	"fmt"
	"strings"

	"github.com/terencetachiona/the-autocompletor/internal/model"
)

// Fish generates a fish completion script for the given command tree.
func Fish(cmd *model.Command) string {
	var b strings.Builder

	fmt.Fprintf(&b, "# Fish completions for %s (generated by theautocompletor)\n\n", cmd.Name)

	if len(cmd.Subcommands) > 0 {
		// Subcommand names for __fish_use_subcommand
		b.WriteString("# Subcommands\n")
		for _, sub := range cmd.Subcommands {
			desc := escapeFish(sub.Description)
			fmt.Fprintf(&b, "complete -c %s -f -n __fish_use_subcommand -a %s -d %q\n",
	cmd.Name, sub.Name, desc)
		}
		b.WriteString("\n")

		// Root flags
		if len(cmd.Flags) > 0 {
			b.WriteString("# Global flags\n")
			for _, f := range cmd.Flags {
				b.WriteString(fishFlag(cmd.Name, "", f))
			}
			b.WriteString("\n")
		}

		// Per-subcommand flags
		for _, sub := range cmd.Subcommands {
			if len(sub.Flags) == 0 {
				continue
			}
			fmt.Fprintf(&b, "# %s\n", sub.Name)
			for _, f := range sub.Flags {
				b.WriteString(fishFlag(cmd.Name, sub.Name, f))
			}
			b.WriteString("\n")
		}
	} else {
		// No subcommands: flat flags
		for _, f := range cmd.Flags {
			b.WriteString(fishFlag(cmd.Name, "", f))
		}
	}

	return b.String()
}

func fishFlag(cmdName, subName string, f model.Flag) string {
	var parts []string
	parts = append(parts, fmt.Sprintf("complete -c %s", cmdName))

	if subName != "" {
		parts = append(parts, fmt.Sprintf("-n \"__fish_seen_subcommand_from %s\"", subName))
	}

	if f.Short != "" {
		short := strings.TrimPrefix(f.Short, "-")
		parts = append(parts, fmt.Sprintf("-s %s", short))
	}
	if f.Long != "" {
		long := strings.TrimPrefix(f.Long, "--")
		parts = append(parts, fmt.Sprintf("-l %s", long))
	}
	if f.TakesArg {
		parts = append(parts, "-x")
	}
	if f.Description != "" {
		parts = append(parts, fmt.Sprintf("-d %q", escapeFish(f.Description)))
	}

	return strings.Join(parts, " ") + "\n"
}

func escapeFish(s string) string {
	return strings.ReplaceAll(s, "'", "\\'")
}
