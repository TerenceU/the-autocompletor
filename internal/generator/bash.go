package generator

import (
	"fmt"
	"strings"

	"github.com/TerenceU/the-autocompletor/internal/model"
)

// Bash generates a bash completion script for the given command tree.
func Bash(cmd *model.Command) string {
	var b strings.Builder
	name := cmd.Name
	fnName := "_" + strings.ReplaceAll(name, "-", "_")

	fmt.Fprintf(&b, "# Bash completions for %s (generated by theautocompletor)\n\n", name)
	fmt.Fprintf(&b, "%s() {\n", fnName)
	b.WriteString("    local cur prev words cword\n")
	b.WriteString("    _init_completion || return\n\n")

	if len(cmd.Subcommands) > 0 {
		subNames := make([]string, len(cmd.Subcommands))
		for i, s := range cmd.Subcommands {
			subNames[i] = s.Name
		}
		fmt.Fprintf(&b, "    local subcommands=%q\n\n", strings.Join(subNames, " "))

		b.WriteString("    # Find if a subcommand has been given\n")
		b.WriteString("    local sub=''\n")
		b.WriteString("    for w in \"${words[@]:1}\"; do\n")
		b.WriteString("        case \"$w\" in\n")
		for _, sub := range cmd.Subcommands {
			flags := buildFlagList(sub.Flags)
			fmt.Fprintf(&b, "            %s)\n                sub=%s; local sub_flags=%q ;;\n", sub.Name, sub.Name, flags)
		}
		b.WriteString("        esac\n")
		b.WriteString("    done\n\n")

		b.WriteString("    if [[ -n \"$sub\" ]]; then\n")
		b.WriteString("        COMPREPLY=($(compgen -W \"$sub_flags\" -- \"$cur\"))\n")
		b.WriteString("        return\n")
		b.WriteString("    fi\n\n")

		rootFlags := buildFlagList(cmd.Flags)
		fmt.Fprintf(&b, "    COMPREPLY=($(compgen -W \"$subcommands %s\" -- \"$cur\"))\n", rootFlags)
	} else {
		flags := buildFlagList(cmd.Flags)
		fmt.Fprintf(&b, "    COMPREPLY=($(compgen -W %q -- \"$cur\"))\n", flags)
	}

	b.WriteString("}\n\n")
	fmt.Fprintf(&b, "complete -F %s %s\n", fnName, name)

	return b.String()
}

func buildFlagList(flags []model.Flag) string {
	var parts []string
	for _, f := range flags {
		if f.Short != "" {
			parts = append(parts, f.Short)
		}
		if f.Long != "" {
			parts = append(parts, f.Long)
		}
	}
	return strings.Join(parts, " ")
}
