package generator

import (
	"fmt"
	"strings"

	"github.com/terencetachiona/the-autocompletor/internal/model"
)

// Bash generates a bash completion script for the given command tree.
func Bash(cmd *model.Command) string {
	var b strings.Builder
	name := cmd.Name
	fnName := "_" + strings.ReplaceAll(name, "-", "_")

	b.WriteString(fmt.Sprintf("# Bash completions for %s (generated by theautocompleter)\n\n", name))
	b.WriteString(fmt.Sprintf("%s() {\n", fnName))
	b.WriteString("    local cur prev words cword\n")
	b.WriteString("    _init_completion || return\n\n")

	if len(cmd.Subcommands) > 0 {
		subNames := make([]string, len(cmd.Subcommands))
		for i, s := range cmd.Subcommands {
			subNames[i] = s.Name
		}
		b.WriteString(fmt.Sprintf("    local subcommands=%q\n\n", strings.Join(subNames, " ")))

		b.WriteString("    # Find if a subcommand has been given\n")
		b.WriteString("    local sub=''\n")
		b.WriteString("    for w in \"${words[@]:1}\"; do\n")
		b.WriteString("        case \"$w\" in\n")
		for _, sub := range cmd.Subcommands {
			flags := buildFlagList(sub.Flags)
			b.WriteString(fmt.Sprintf("            %s)\n                sub=%s; local sub_flags=%q ;;\n", sub.Name, sub.Name, flags))
		}
		b.WriteString("        esac\n")
		b.WriteString("    done\n\n")

		b.WriteString("    if [[ -n \"$sub\" ]]; then\n")
		b.WriteString("        COMPREPLY=($(compgen -W \"$sub_flags\" -- \"$cur\"))\n")
		b.WriteString("        return\n")
		b.WriteString("    fi\n\n")

		rootFlags := buildFlagList(cmd.Flags)
		b.WriteString(fmt.Sprintf("    COMPREPLY=($(compgen -W \"$subcommands %s\" -- \"$cur\"))\n", rootFlags))
	} else {
		flags := buildFlagList(cmd.Flags)
		b.WriteString(fmt.Sprintf("    COMPREPLY=($(compgen -W %q -- \"$cur\"))\n", flags))
	}

	b.WriteString("}\n\n")
	b.WriteString(fmt.Sprintf("complete -F %s %s\n", fnName, name))

	return b.String()
}

func buildFlagList(flags []model.Flag) string {
	var parts []string
	for _, f := range flags {
		if f.Short != "" {
			parts = append(parts, f.Short)
		}
		if f.Long != "" {
			parts = append(parts, f.Long)
		}
	}
	return strings.Join(parts, " ")
}
